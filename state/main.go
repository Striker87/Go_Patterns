package main

import (
	"log"
	"patterns/state/pkg"
)

/*
Состояние — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния.
Извне создаётся впечатление, что изменился объект.

Проблема:
Основная идея паттерна Состояние в том, что программа может находиться в одном из нескольких состояний, которые всё время сменяют друг друга.
Набор этих состояний, а также переходов между ними, предопределён и конечен.
Находясь в разных состояниях, программа может по-разному реагировать на одни и те же события, которые происходят с ней.

Такой подход можно применить и к отдельным объектам.
Например, объект Документ может принимать три состояния: Черновик, Модерация или Опубликован.
В каждом из этих состоянии метод опубликовать будет работать по-разному:

Из черновика он отправит документ на модерацию.
Из модерации — в публикацию, но при условии, что это сделал администратор.
В опубликованном состоянии метод не будет делать ничего.

Решение:
Паттерн Состояние предлагает создать отдельные объекты для каждого состояния, в котором может пребывать объект, а затем вынести туда поведения, соответствующие этим состояниям.
Вместо того, чтобы хранить код всех состояний, первоначальный объект, называемый контекстом, будет содержать ссылку на один из объектов-состояний и делегировать ему работу, зависящую от состояния.

Благодаря тому, что объекты состояний будут иметь общий интерфейс, контекст сможет делегировать работу состоянию, не привязываясь к его классу.

Поведение контекста можно будет изменить в любой момент, подключив к нему другой объект-состояние.

Очень важным нюансом, отличающим этот паттерн от Стратегии, является то, что и контекст, и сами конкретные состояния могут знать друг о друге и инициировать переходы от одного состояния к другому.

Применение на практике:
- Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, причём типов состояний много, и их код часто меняется.
Паттерн предлагает выделить в собственные типы все поля и методы, связанные с определёнными состояниями. Первоначальный объект будет постоянно ссылаться на один из объектов-состояний, делегируя ему часть своей работы. Для изменения состояния в контекст достаточно будет подставить другой объект-состояние.
- Когда код объекта содержит множество больших, похожих друг на друга, условных операторов, которые выбирают поведения в зависимости от текущих значений полей этого объекта.
Паттерн предлагает переместить каждую ветку такого условного оператора в собственный класс. Тут же можно поселить и все поля, связанные с данным состоянием.
- Когда вы сознательно используете табличную модель состояний, построенную на условных операторах, но вынуждены мириться с дублированием кода для похожих состояний и переходов.
Паттерн Состояние позволяет реализовать иерархическую машину состояний, базирующуюся на наследовании. Вы можете наследовать похожие состояния от одного родительского объекта и
вынести туда весь дублирующий код.

Преимущества:
+ Избавляет от множества больших условных операторов машины состояний.
+ Концентрирует в одном месте код, связанный с определённым состоянием.
+ Упрощает код контекста.

Недостатки:
-Может неоправданно усложнить код, если состояний мало и они редко меняются.

Концептуальный пример:
Давайте применим паттерн проектирования Состояние в контексте торговых автоматов. Для упрощения задачи представим, что торговый автомат может выдавать только один товар. Также представим, что автомат может пребывать только в одном из четырех состояний:

Торговый автомат может иметь различные действия. Для простоты оставим только четыре из них:

* Выбрать предмет
* Добавить предмет
* Ввести деньги
* Выдать предмет

Паттерн Состояние нужно использовать в случаях, когда объект может иметь много различных состояний, которые он должен менять в зависимости от конкретного поступившего запроса.
*/

func main() {
	vendingMachine := pkg.NewVendingMachine(1, 10)

	err := vendingMachine.RequestItem()
	if err != nil {
		log.Fatal(err)
	}

	err = vendingMachine.InsertMoney(10)
	if err != nil {
		log.Fatal(err)
	}

	err = vendingMachine.DispenseItem()
	if err != nil {
		log.Fatal(err)
	}

	err = vendingMachine.AddItem(2)
	if err != nil {
		log.Fatal(err)
	}

	err = vendingMachine.RequestItem()
	if err != nil {
		log.Fatal(err)
	}

	err = vendingMachine.InsertMoney(10)
	if err != nil {
		log.Fatal(err)
	}
}
